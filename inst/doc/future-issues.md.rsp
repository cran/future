<%@meta language="R-vignette" content="--------------------------------
%\VignetteIndexEntry{Futures in R: Common issues with solutions}
%\VignetteAuthor{Henrik Bengtsson}
%\VignetteKeyword{R}
%\VignetteKeyword{package}
%\VignetteKeyword{vignette}
%\VignetteKeyword{future}
%\VignetteKeyword{promise}
%\VignetteEngine{R.rsp::rsp}
%\VignetteTangle{FALSE}
--------------------------------------------------------------------"%>
# <%@meta name="title"%>

In the ideal case all it takes to start using futures in R is to replace any standard assignment (`<-`) in your R code with a future assignment (`%<=%`) and make sure your right-hand side (RHS) expression is within curly brackets (`{ ... }`).  Also, if you assign these to lists (e.g. in a for loop), you need to use a list environment (`listenv`) instead of a plain list.

However, there are few cases where you have to take extra precautions.  These are often related to how global variables are falsely identified in non-standard evaluation, e.g. `subset(data, x < 3)`.  Global variables need to be identified when futures are created, but this is a particularly hard task when non-standard evaluation is involved.

_If you identify other use cases, please consider [reporting](https://github.com/HenrikBengtsson/future/issues/) them so they can be documented here and possibly even be fixed._



## False globals due to non-standard evaluation

### subset(data, x < 3)

Consider the following use of `subset()`:
```r
> data <- data.frame(x=1:5, y=1:5)
> v <- subset(data, x < 3)$y
> v
[1] 1 2
```
From a static code inspection point of view, the expression `x < 3` asks for variable `x` to be compared to 3, and there is nothing specifying that `x` is part of `data` and not the global environment.  That `x` is indeed part of the `data` object can only safely be inferred at run time when `subset()` is called.  This is not a problem in the above snipped, but when using futures all global/unknown variables need to be captured when the future is created (it is too late to do it when the future is resolved), e.g.
```r
> library(future)
> plan(lazy)
> data <- data.frame(x=1:5, y=1:5)
> v %<=% subset(data, x < 3)$y
Error in globalsOf(expr, envir = envir, tweak = tweakExpression, dotdotdot = "return",  :
  Identified a global by static code inspection, but failed to locate the corresponding
  object in the relevant environments: 'x'
```
Above, code inspection of the future expression `subset(data, x < 3)$y` incorrectly identifies `x` as a global variables that needs to be captured ("frozen") for the (lazy) future.  Since no such variable `x` exists, we get an error.
The same error would be reported when using `plan(eager, globals=TRUE)` or `plan(multicore, globals=TRUE)`, which validates globals _before_ the future is created.

The most clear and backward-compatible solution to this problem is to explicitly specify the context of `x`, i.e.
```r
> data <- data.frame(x=1:5, y=1:5)
> v %<=% subset(data, data$x < 3)$y
> v
[1] 1 2
```

An alternative is to use a dummy variable.  In contrast to the code-inspection algorithm used to identify globals, _we know from reading the documentation_ that `subset()` will look for `x` in the `data` object, not in the parent environments.  Armed with this knowledge, we can trick the [future] package (more precisely the [globals] package) to pickup a dummy variable `x` instead, e.g.
```r
> data <- data.frame(x=1:5, y=1:5)
> x <- NULL ## To please future et al.
> v %<=% subset(data, x < 3)$y
> v
[1] 1 2
```

### ggplot2
Another common use case for non-standard evaluation is when creating ggplot2 figures.  For instance, in
```r
> library(ggplot2)
> p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
> p
```
fields `mpg` and `wt` of the `mtcars` data object are plotted against each other.  That `mpg` and `wt` are actually fields of `mtcars` can not be inferred from code inspection alone, but you need know that that is how ggplot2 works.  Analogously to the above `subset()` example, this explains why we get the following error:
```r
> library(future)
> plan(lazy)
> library(ggplot2)
> p %<=% { ggplot(mtcars, aes(wt, mpg)) + geom_point() }
Error in globalsOf(expr, envir = envir, tweak = tweakExpression, dotdotdot = "return",  :
  Identified a global by static code inspection, but failed to locate the corresponding
  object in the relevant environments: 'wt'
```
A few comments are needed here.  First of all, because `%<=%` has higher precedence than `+`, we need to place all of the ggplot2 expression within curly brackets, otherwise we get an error.  Second, the reason for only `wt` being listed as a missing global variable and not `mpg` is because the latter is (incorrectly) located to be `ggplot2::mpg`.

One workaround is to make use of the `*_string()` functions of ggplot2, e.g.
```r
> p %<=% { ggplot(mtcars, aes_string('wt', 'mpg')) + geom_point() }
> p
```
Another one, is to explicitly specify `mtcars$wt` and `mtcars$mpg`, which may become a bit tedious.
A third alternative is to make use of dummy variables `wt` and `mpg`, i.e.
```r
> p %<=% {
+   wt <- mpg <- NULL
+   ggplot(mtcars, aes(wt, mpg)) + geom_point()
+ }
> p
```
By the way, since all futures are evaluated in a local environment, the dummy variables are _not_ assigned to the calling environment.


## Missing or incorrect globals

## Global variable obscured by subassignment
When a global variable is a vector, a matrix, a list, a data frame, an environment, or any other type of object that can be assigned via subsetting, the global package fails to identify it as a global variable if its first occurance in the future expression is as part of a subsetting assignment.
For example,
```r
> library(future)
> plan(lazy)
> x <- matrix(1:12, nrow=3, ncol=4)
> y %<=% {
+   x[1,1] <- 3
+   42
+ }
> rm(x)
> y
Error in x[1, 1] <- 3 : object 'x' not found
```
Another example is
```r
> library(future)
> plan(lazy)
> x <- list(a=1, b=2)
> y %<=% {
+   x$c <- 3
+   42
+ }
> rm(x)
> y
Error in x$c <- 3 : object 'x' not found
```
A workaround is to explicitly tell the future package about the global variable by simply listing it at the beginning of the expression, e.g.
```r
> library(future)
> plan(lazy)
> x <- list(a=1, b=2)
> y %<=% {
+   x  ## Force 'x' to be global
+   x$c <- 3
+   42
+ }
> rm(x)
> y
[1] 42
```



## Error "non-numeric argument to binary operator"

The future assignment operator `%<=%` is a _binary infix operator_, which means it has higher precedence than most other binary operators but also higher than some of the unary operators in R.  For instance, this explains why we get the following error:
```r
> x %<=% 2 * runif(1)
Error in x %<=% 2 * runif(1) : non-numeric argument to binary operator
```
What effectively is happening here is that because of the higher priority of `%<=%`, we first create a future `x %<=% 2` and then we try to multiply it (not its value) with the value of `runif(1)` - which makes no sense.  In order to properly assign the future variable, we need need to put the future expression within curly brackets;
```r
> x %<=% { 2 * runif(1) }
> x
[1] 1.030209
```
Parentheses will also do.  For details on precedence on operators in R, see Section 'Infix and prefix operators' in the 'R Language Definition' document.



[BatchJobs]: https://cran.r-project.org/package=BatchJobs
[codetools]: https://cran.r-project.org/package=codetools
[future]: https://cran.r-project.org/package=future
[globals]: https://cran.r-project.org/package=globals
[listenv]: https://cran.r-project.org/package=listenv
[async]: https://github.com/HenrikBengtsson/async/

---
Copyright Henrik Bengtsson, 2015
